# **Homework 2 for October 2, 2024**  

![Languages Flowchart](progLangChartPuzzle.pdf)  

**Sort the above languages chronologically and write them here. Write down the decade during which these languages were developed.**  
---
+  FORTRAN (1950s)
  
+  Algol 58 (1950s)

+  Lisp (1950s)

+  BASIC (1960s)

+  C (1970s)

+  sh (1970s)
  
+  C++ (1980s)

+  Python (1990s)

+  Fortran 90 (1990s)

+  Java (1990s)

+  JavaScript (1990s)

+  C# (2000s)



What does ENIAC stand for?  
+  ENIAC: Electronic Numerical Integrator and Computer.

Why do integers in computers represent everything?  
+  Computers use binary (0s and 1s), integer values because digital circuits are designed to represent two distinct states (on/off), making binary the most fundamental representation of data.

What is the name of the fastest part of the computer memory?
+  Registers.

What is the slowest storage device in computers (typically integrated with computers)?
+  Hard Disk Drives (HDD).

What is the smallest unit of information in computer science?
+  Bit.

(A) What is the closest programming language to machine code (i.e., binary code)?
+  Assembly language.

(B) Does it need interpretation to become machine-comprehensible?
+  Yes, assembly code needs to be assembled (translated) into machine code by an assembler.
  
(A) Name the oldest high-level programming language that is still in active daily use.  
+  FORTRAN.
  
(B) Approximately how many decades is it old?  
+  FORTRAN is about 7 decades.
  
(A) Name a second-generation programming language.  
+  Assembly language.
  
(B) Which language generation are Fortran, C, C++, MATLAB, Python, R?  
+  These are third-generation programming languages.
  
In what decades were C, C++, and MATLAB/Python created, respectively?  
+  C: 1970
+  C++: 1980
+  MATLAB: 1980
+  Python: 1990
  
Name an ancestor programming language of C.  
+  B.
  
Name a programming language ancestor of C++.  
+  C.
  
Name a programming language ancestor of MATLAB and a programming language ancestor of Python.  
+  MATLAB: FORTRAN
+  Python: ABC

**Memory Hierarchy and Performance:**
---
What is the fastest part of the memory in the memory hierarchy of modern computers?  
+  Registers.
  
What is typically the smallest memory unit in the memory hierarchy of modern computers?  
+  Bit.
  
How much faster is the access to the register memory compared to RAM in modern computers?  
+  Registers are about 100 to 1000 times faster than RAM.
  
How much faster is the access to RAM compared to typical SSD hard drives in modern computers?  
+  RAM is about 100 times faster than SSDs.
  
How much faster is the access to RAM compared to typical HDD hard drives in modern computers?  
+  RAM is about 10,000 to 100,000 times faster than HDDs.

**Transistors and CPU:**  
---
What are the primary roles of transistors in computers?  
+  Transistors act as switches and amplifiers for electrical signals, enabling logic operations and data storage.
  
Why can't we add more transistors to computers to make them faster?  
+  More transistors increase heat output and power consumption, leading to diminishing returns and physical limits on chip design.
  
What are the three tasks accomplished within a CPU cycle?  
+  Fetch, Decode, and Execute.
  
Can a powerful computer with more CPU cycles be slower than a computer with fewer CPU cycles? Why or How?  
+  Yes, if the memory access speed is slower, the CPU will be waiting for data, resulting in a bottleneck, regardless of the CPU cycles.
  
What is the bottleneck of speed in modern computers? CPU clocks or memory access? Why?  
+  Memory access is often the bottleneck because data retrieval from RAM or storage is significantly slower than the CPU clock cycle.

**Moore’s Law and Scaling:**  
---
What is the difference between Dennard Scaling, MOSFET scaling, and Moore’s law?  
+  Moore’s Law refers to the doubling of transistors on a chip approximately every two years, leading to increased processing power.
+  Dennard Scaling explains how as transistors shrink, power density stays constant, allowing for faster speeds and lower power consumption.
+  MOSFET Scaling refers to the process of shrinking the size of MOSFET transistors while maintaining efficiency.

**Chessboard Question:**  
---
Consider the following chessboard.  
Suppose I ask you to put a single rice grain in the first square.  
Then I ask you to put incrementally one more grain in each new square than the previous one:  
1, 2, 3, 4, 5, …  
How many grains would you need to put in the last (64th) square?  
+  64 grains.

How many grains overall would you need to fill all chessboard squares incrementally as described above?  
+  2080 grains.
  
A pound of rice is roughly 7000 grains. How many pounds of rice would you need for this task?  
+  0.297 pounds of rice.
  
How many grains would you need to put in the last (64th) square?
+  9.2×10^18 grains.
  
How many grains would you need to fill the last chessboard square geometrically as described above?
+  1.84×10^19 grains.

A pound of rice is roughly 7000 grains. How many pounds of rice would you need for this task?
+  2.63×10^15 pounds.
  
The current annual world production of rice is roughly 2×1012=2,000,000,000,000 lbs. How many years will it take to produce the required amount of rice grains to place on this chessboard in this fashion?
+  1315 years.

What are the three fundamental components of a Turing-complete language?
+  Conditional branching, looping, and memory manipulation (read/write operations).

**Extra credit:**  
---
How would you distinguish exponential behavior vs. power-law behavior (function) in a 2-dimensional plot?  
+  Exponential behavior grows much faster, curving sharply upward, whereas power-law behavior grows more slowly and steadily over time, represented by a straight line on a log-log plot.
